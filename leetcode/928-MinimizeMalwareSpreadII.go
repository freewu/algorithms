package main

// 928. Minimize Malware Spread II
// You are given a network of n nodes represented as an n x n adjacency matrix graph, 
// where the ith node is directly connected to the jth node if graph[i][j] == 1.

// Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, 
// and at least one of those two nodes is infected by malware, both nodes will be infected by malware. 
// This spread of malware will continue until no more nodes can be infected in this manner.

// Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.

// We will remove exactly one node from initial, completely removing it and any connections from this node to any other node.

// Return the node that, if removed, would minimize M(initial). 
// If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

// Example 1:
// Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
// Output: 0

// Example 2:
// Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
// Output: 1

// Example 3:
// Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
// Output: 1
 
// Constraints:
//     n == graph.length
//     n == graph[i].length
//     2 <= n <= 300
//     graph[i][j] is 0 or 1.
//     graph[i][j] == graph[j][i]
//     graph[i][i] == 1
//     1 <= initial.length < n
//     0 <= initial[i] <= n - 1
//     All the integers in initial are unique.

import "fmt"

// bfs
func minMalwareSpread(graph [][]int, initial []int) int {
    linker := make([][]int, len(graph))
    for i := 0; i < len(graph); i++ {
        for j := i + 1; j < len(graph); j++ {
            if graph[i][j] == 1 {
                linker[i] = append(linker[i], j)
                linker[j] = append(linker[j], i)
            }
        }
    }
    minSpread, minSpreadIndex := 1 << 32 - 1, 0
    // we can only remove from initial!!! I GOT WA because I try to remove from 0 to n-1
    for _, removeIndex := range initial {
        infected, reached := 0, make([]bool, len(graph))
        reached[removeIndex] = true
        curr := make([]int, 0, len(initial))
        for _, v := range initial {
            reached[v] = true
            if v != removeIndex {
                infected++
                curr = append(curr, v)
            }
        }
        // bfs
        for len(curr) > 0 {
            next := make([]int, 0, 16)
            for _, index := range curr {
                for _, v := range linker[index] {
                    if reached[v] == true {
                        continue
                    }
                    reached[v] = true
                    infected++
                    next = append(next, v)
                }
            }
            curr = next
        }
        if infected < minSpread || (infected == minSpread && removeIndex < minSpreadIndex) {
            minSpread = infected
            minSpreadIndex = removeIndex
        }
    }
    return minSpreadIndex
}

// 并查集
func minMalwareSpread1(graph [][]int, initial []int) int {
    n := len(graph)
    initialSet := make([]int, n)
    for _, v := range initial {
        initialSet[v] = 1
    }
    uf := make([]int, n)
    for u := 0; u < n; u++ {
        uf[u] = u
    }
    var find func(uf []int, u int) int
    find = func(uf []int, u int) int {
        if uf[u] == u {
            return u
        }
        uf[u] = find(uf, uf[u])
        return uf[u]
    }
    merge := func (uf []int, u, v int) {
        ru, rv := find(uf, u), find(uf, v)
        uf[ru] = rv
    }
    for u := 0; u < n; u++ {
        if initialSet[u] == 1 {
            continue
        }
        for v := 0; v < n; v++ {
            if initialSet[v] == 1 {
                continue
            }
            if graph[u][v] == 1 {
                merge(uf, u, v)
            }
        }
    }
    infectedBy := make([][]int, n)
    for _, v := range initial {
        infectedSet := make([]int, n)
        for u := 0; u < n; u++ {
            if initialSet[u] == 1 || graph[u][v] == 0 {
                continue
            }
            infectedSet[find(uf, u)] = 1
        }
        for u := 0; u < n; u++ {
            if infectedSet[u] == 1 {
                infectedBy[u] = append(infectedBy[u], v)
            }
        }
    }
    count := make([]int, n)
    for u := 0; u < n; u++ {
        if len(infectedBy[u]) != 1 {
            continue
        }
        v := infectedBy[u][0]
        for w := 0; w < n; w++ {
            if find(uf, w) == find(uf, u) {
                count[v]++
            }
        }
    }
    res := initial[0]
    for _, v := range initial {
        if count[v] > count[res] || count[v] == count[res] && v < res {
            res = v
        }
    }
    return res
}

func minMalwareSpread2(graph [][]int, initial []int) int {
    minimum, idx, g := 1 << 32 - 1, -1, newGraph(graph)
    for _, deleted := range initial {
        g.reset()
        g.deleted = deleted

        for _, node := range initial {
            g.dfs(node)
        }
        if g.count < minimum || g.count == minimum && deleted < idx {
            minimum = g.count
            idx = deleted
        }

    }
    return idx
}

type tGraph struct {
    nodes    [][]int
    infected []bool
    deleted  int
    count    int
}

func newGraph(matrix [][]int) *tGraph {
    nodes := make([][]int, len(matrix))
    for a, row := range matrix {
        for b := a + 1; b < len(row); b++ {
            if row[b] == 1 {
                nodes[a] = append(nodes[a], b)
                nodes[b] = append(nodes[b], a)
            }
        }
    }
    return &tGraph{
        nodes:    nodes,
        infected: make([]bool, len(matrix)),
    }
}

func (g *tGraph) reset() {
    clear(g.infected)
    g.count = 0
}

func (g *tGraph) dfs(node int) {
    if node == g.deleted || g.infected[node] {
        return
    }
    g.count += 1
    g.infected[node] = true
    for _, neig := range g.nodes[node] {
        g.dfs(neig)
    }
}

func main() {
    fmt.Println(minMalwareSpread([][]int{{1,1,0},{1,1,0},{0,0,1}},[]int{0,1})) // 0
    fmt.Println(minMalwareSpread([][]int{{1,1,0},{1,1,1},{0,1,1}},[]int{0,1})) // 1
    fmt.Println(minMalwareSpread([][]int{{1,1,0,0},{1,1,1,0},{0,1,1,1},{0,0,1,1}},[]int{1,2})) // 1

    fmt.Println(minMalwareSpread1([][]int{{1,1,0},{1,1,0},{0,0,1}},[]int{0,1})) // 0
    fmt.Println(minMalwareSpread1([][]int{{1,1,0},{1,1,1},{0,1,1}},[]int{0,1})) // 1
    fmt.Println(minMalwareSpread1([][]int{{1,1,0,0},{1,1,1,0},{0,1,1,1},{0,0,1,1}},[]int{1,2})) // 1

    fmt.Println(minMalwareSpread2([][]int{{1,1,0},{1,1,0},{0,0,1}},[]int{0,1})) // 0
    fmt.Println(minMalwareSpread2([][]int{{1,1,0},{1,1,1},{0,1,1}},[]int{0,1})) // 1
    fmt.Println(minMalwareSpread2([][]int{{1,1,0,0},{1,1,1,0},{0,1,1,1},{0,0,1,1}},[]int{1,2})) // 1
}