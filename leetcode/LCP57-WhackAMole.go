package main

// LCP 57. 打地鼠
// 欢迎各位勇者来到力扣城，本次试炼主题为「打地鼠」。
// <img src="https://pic.leetcode-cn.com/1650273183-nZIijm-middle_img_v2_d5d09656-0616-4a80-845e-ece461c5ba9g.png" />

// 勇者面前有一个大小为3*3 的打地鼠游戏机，地鼠将随机出现在各个位置，
// moles[i] = [t,x,y] 表示在第 t 秒会有地鼠出现在 (x,y) 位置上，并于第 t+1 秒该地鼠消失。

// 勇者有一把可敲打地鼠的锤子，初始时刻（即第 0 秒）锤子位于正中间的格子 (1,1)，锤子的使用规则如下：
//     1. 锤子每经过 1 秒可以往上、下、左、右中的一个方向移动一格，也可以不移动
//     2. 锤子只可敲击所在格子的地鼠，敲击不耗时

// 请返回勇者最多能够敲击多少只地鼠。

// 注意：
//     输入用例保证在相同时间相同位置最多仅有一只地鼠

// 示例 1：
// 输入： moles = [[1,1,0],[2,0,1],[4,2,2]]
// 输出： 2
// 解释： 第 0 秒，锤子位于 (1,1) 第 1 秒，锤子移动至 (1,0) 并敲击地鼠 第 2 秒，锤子移动至 (2,0) 第 3 秒，锤子移动至 (2,1) 第 4 秒，锤子移动至 (2,2) 并敲击地鼠 因此勇者最多可敲击 2 只地鼠

// 示例 2：
// 输入：moles = [[2,0,2],[5,2,0],[4,1,0],[1,2,1],[3,0,2]]
// 输出：3
// 解释： 第 0 秒，锤子位于 (1,1) 第 1 秒，锤子移动至 (2,1) 并敲击地鼠 第 2 秒，锤子移动至 (1,1) 第 3 秒，锤子移动至 (1,0) 第 4 秒，锤子在 (1,0) 不移动并敲击地鼠 第 5 秒，锤子移动至 (2,0) 并敲击地鼠 因此勇者最多可敲击 3 只地鼠

// 示例 3：
// 输入：moles = [[0,1,0],[0,0,1]]
// 输出：0
// 解释： 第 0 秒，锤子初始位于 (1,1)，此时并不能敲击 (1,0)、(0,1) 位置处的地鼠

// 提示：
//     1 <= moles.length <= 10^5
//     moles[i].length == 3
//     0 <= moles[i][0] <= 10^9
//     0 <= moles[i][1], moles[i][2] < 3

import "fmt"
import "sort"

func getMaximumNumber(moles [][]int) int {
    // 必须按照时间排序，否则在考虑一个地鼠是否可达的时候会出问题。比如说(0,2,0)显然是不可达的，因为初始位置在（1,1）。考虑一种情形，(1,1,0)是可达的,
    //如果(0,2,0)紧跟其后，就会误判(0,2,0)可达。我把这个叫做时间倒流陷阱。
    sort.Slice(moles, func(i, j int) bool {
        return moles[i][0] < moles[j][0]
    })
    abs := func(x int) int { if x < 0 { return -x; }; return x; }
    max := func (x, y int) int { if x > y { return x; }; return y; }
    res, n := 0, len(moles)
    dp, pre := make([]int, n), make([]int, n)
    for i := 0; i < n; i++ {
        for j := i - 1; j >= 0; j-- {
            t := moles[i][0] - moles[j][0]
            // 可以从前面任意一个位置过来，所以直接取前缀最大值
            if t >= 4 {
                dp[i] = max(dp[i], pre[j]+1)
                break
            }
            // dp[j] == 0表示这个地鼠是不可能达到的
            if dp[j] > 0 && t >= abs(moles[i][1] - moles[j][1]) + abs(moles[i][2] - moles[j][2]) {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
        // 考虑从初始位置是否可达
        if dp[i] == 0 && abs(moles[i][0] - 0) >= abs(moles[i][1] - 1) + abs(moles[i][2] - 1) {
            dp[i] = 1
        }
        res = max(res, dp[i])
        if i == 0 {
            pre[0] = dp[0]
        } else {
            pre[i] = max(pre[i-1], dp[i])
        }
    }
    return res
}

func main() {
    // 示例 1：
    // 输入： moles = [[1,1,0],[2,0,1],[4,2,2]]
    // 输出： 2
    // 解释： 第 0 秒，锤子位于 (1,1) 第 1 秒，锤子移动至 (1,0) 并敲击地鼠 第 2 秒，锤子移动至 (2,0) 第 3 秒，锤子移动至 (2,1) 第 4 秒，锤子移动至 (2,2) 并敲击地鼠 因此勇者最多可敲击 2 只地鼠
    fmt.Println(getMaximumNumber([][]int{{1,1,0},{2,0,1},{4,2,2}})) // 2
    // 示例 2：
    // 输入：moles = [[2,0,2],[5,2,0],[4,1,0],[1,2,1],[3,0,2]]
    // 输出：3
    // 解释： 第 0 秒，锤子位于 (1,1) 第 1 秒，锤子移动至 (2,1) 并敲击地鼠 第 2 秒，锤子移动至 (1,1) 第 3 秒，锤子移动至 (1,0) 第 4 秒，锤子在 (1,0) 不移动并敲击地鼠 第 5 秒，锤子移动至 (2,0) 并敲击地鼠 因此勇者最多可敲击 3 只地鼠
    fmt.Println(getMaximumNumber([][]int{{2,0,2},{5,2,0},{4,1,0},{1,2,1},{3,0,2}})) // 3
    // 示例 3：
    // 输入：moles = [[0,1,0],[0,0,1]]
    // 输出：0
    // 解释： 第 0 秒，锤子初始位于 (1,1)，此时并不能敲击 (1,0)、(0,1) 位置处的地鼠
    fmt.Println(getMaximumNumber([][]int{{0,1,0},{0,0,1}})) // 0
}