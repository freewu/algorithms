package main

// 3474. Lexicographically Smallest Generated String
// You are given two strings, str1 and str2, of lengths n and m, respectively.

// A string word of length n + m - 1 is defined to be generated by str1 
// and str2 if it satisfies the following conditions for each index 0 <= i <= n - 1:
//     1. If str1[i] == 'T', the substring of word with size m starting at index i is equal to str2, 
//        i.e., word[i..(i + m - 1)] == str2.
//     2. If str1[i] == 'F', the substring of word with size m starting at index i is not equal to str2, 
//        i.e., word[i..(i + m - 1)] != str2.

// Return the lexicographically smallest possible string that can be generated by str1 and str2. 
// If no string can be generated, return an empty string "".

// Example 1:
// Input: str1 = "TFTF", str2 = "ab"
// Output: "ababa"
// Explanation:
// The table below represents the string "ababa"
// Index	T/F	Substring of length m
// 0	'T'	"ab"
// 1	'F'	"ba"
// 2	'T'	"ab"
// 3	'F'	"ba"
// The strings "ababa" and "ababb" can be generated by str1 and str2.
// Return "ababa" since it is the lexicographically smaller string.

// Example 2:
// Input: str1 = "TFTF", str2 = "abc"
// Output: ""
// Explanation:
// No string that satisfies the conditions can be generated.

// Example 3:
// Input: str1 = "F", str2 = "d"
// Output: "a"

// Constraints:
//     1 <= n == str1.length <= 10^4
//     1 <= m == str2.length <= 500
//     str1 consists only of 'T' or 'F'.
//     str2 consists only of lowercase English characters.

import "fmt"
import "sort"
import "bytes"

func generateString(str1 string, str2 string) string {
    ls, m, n := -1, len(str1), len(str2)
    bt := make([]byte, m+n-1)
    // built string with case 'T'
    for i := range str1 {
        if str1[i] == 'T' {
            if ls != -1 && ls+n > i {
                if str2[i-ls:] != str2[:n+ls-i] {
                    return ""
                }
            }
            copy(bt[i:i+n], []byte(str2))
            ls = i
        }
    }
    // check invalid case 'F'
    for i := len(bt) - 1; i >= 0; i-- {
        if i <= m-1 && str1[i] == 'F' && string(bt[i:i+n]) == str2 {
            return ""
        }
    }
    v0 := []int{}
    // set default value 'a'
    for i := range bt {
        if bt[i] == 0 {
            v0 = append(v0, i)
            bt[i] = 'a'
        }
    }
    // try to change value default if case 'F' is invalid
    for i := 0; i < len(bt); i++ {
        if i <= m-1 && str1[i] == 'F' && string(bt[i:i+n]) == str2 {
            // update last +1
            // find data from i -> i+n in v0
            idx, _ := sort.Find(len(v0), func(iv int) int {
                return i + n - v0[iv]
            })
            ic := -1
            if idx == len(v0) {
                ic = v0[len(v0)-1]
            } else {
                ic = v0[idx-1]
            }
            bt[ic]++
        }
    }
    return string(bt)
}

func generateString1(s, t string) string {
    n, m := len(s), len(t)
    res := bytes.Repeat([]byte{'?'}, n + m - 1)
    min := func (x, y int) int { if x < y { return x; }; return y; }
    max := func (x, y int) int { if x > y { return x; }; return y; }
    calc := func(s string) []int {
        n, boxL, boxR := len(s), 0, 0 // z-box 左右边界（闭区间）
        z := make([]int, n)
        for i := 1; i < n; i++ {
            if i <= boxR {
                z[i] = min(z[i-boxL], boxR-i+1)
            }
            for i+z[i] < n && s[z[i]] == s[i+z[i]] {
                boxL, boxR = i, i+z[i]
                z[i]++
            }
        }
        z[0] = n
        return z
    }
    // 处理 T
    pre := -m
    z := calc(t)
    for i, b := range s {
        if b != 'T' { continue }
        size := max(pre + m - i, 0)
        // t 的长为 size 的前后缀必须相同
        if size > 0 && z[m - size] < size {
            return ""
        }
        // size 后的内容都是 '?'，填入 t
        copy(res[i + size:], t[size:])
        pre = i
    }
    // 计算 <= i 的最近待定位置
    preQ := make([]int, len(res))
    pre = -1
    for i, c := range res {
        if c == '?' {
            res[i] = 'a' // 待定位置的初始值为 a
            pre = i
        }
        preQ[i] = pre
    }
    // 找 ans 中的等于 t 的位置，可以用 KMP 或者 Z 函数
    z = calc(t + string(res))
    // 处理 F
    for i := 0; i < n; i++ {
        if s[i] != 'F' { continue }
        // 子串必须不等于 t 
        if z[m + i] < m { continue }
        // 找最后一个待定位置
        j := preQ[i + m - 1]
        if j < i { // 没有
            return ""
        }
        res[j] = 'b'
        i = j // 直接跳到 j
    }
    return string(res)
}

func generateString2(str1 string, str2 string) string {
    n, m := len(str1), len(str2)
    buf, fixed := make([]byte, n + m - 1), make([]bool, n + m - 1)
    for i := range buf {
        buf[i] = 'a'
    }
    for i := range str1 {
        if str1[i] == 'F' { continue }
        for j := range str2 {
            if fixed[i + j] && buf[i + j] != str2[j] {
                return ""
            }
            fixed[i + j] = true
            buf[i + j] = str2[j]
        }
    }
    max := func (x, y int) int { if x > y { return x; }; return y; }
    for i := m - 1; i < n + m - 1; i++ {
        if str1[i-m+1] == 'T' { continue }
        if string(buf[i - m + 1:i + 1]) != str2 { continue }
        for i >= 0 {
            if fixed[i] {
                i--
                continue
            }
            if buf[i] == 'z' {
                buf[i] = 'a'
                i--
                continue
            }
            break
        }
        if i < 0 {
            return ""
        }
        buf[i]++
        i = max(i, m - 1)
        i--
    }
    return string(buf)
}

func main() {
    // Example 1:
    // Input: str1 = "TFTF", str2 = "ab"
    // Output: "ababa"
    // Explanation:
    // The table below represents the string "ababa"
    // Index	T/F	Substring of length m
    // 0	'T'	"ab"
    // 1	'F'	"ba"
    // 2	'T'	"ab"
    // 3	'F'	"ba"
    // The strings "ababa" and "ababb" can be generated by str1 and str2.
    // Return "ababa" since it is the lexicographically smaller string.
    fmt.Println(generateString("TFTF", "ab")) // ababa
    // Example 2:
    // Input: str1 = "TFTF", str2 = "abc"
    // Output: ""
    // Explanation:
    // No string that satisfies the conditions can be generated.
    fmt.Println(generateString("TFTF", "abc")) // ""
    // Example 3:
    // Input: str1 = "F", str2 = "d"
    // Output: "a"
    fmt.Println(generateString("F", "d")) // a

    fmt.Println(generateString("TFTFTFTF", "bluefrog")) // ""
    fmt.Println(generateString("TFTFTFTF", "leetcode")) // ""

    fmt.Println(generateString1("TFTF", "ab")) // ababa
    fmt.Println(generateString1("TFTF", "abc")) // ""
    fmt.Println(generateString1("F", "d")) // a
    fmt.Println(generateString1("TFTFTFTF", "bluefrog")) // ""
    fmt.Println(generateString1("TFTFTFTF", "leetcode")) // ""

    fmt.Println(generateString2("TFTF", "ab")) // ababa
    fmt.Println(generateString2("TFTF", "abc")) // ""
    fmt.Println(generateString2("F", "d")) // a
    fmt.Println(generateString2("TFTFTFTF", "bluefrog")) // ""
    fmt.Println(generateString2("TFTFTFTF", "leetcode")) // ""
}