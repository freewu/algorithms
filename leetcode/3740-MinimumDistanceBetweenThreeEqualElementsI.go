package main

// 3740. Minimum Distance Between Three Equal Elements I
// You are given an integer array nums.

// A tuple (i, j, k) of 3 distinct indices is good if nums[i] == nums[j] == nums[k].

// The distance of a good tuple is abs(i - j) + abs(j - k) + abs(k - i), where abs(x) denotes the absolute value of x.

// Return an integer denoting the minimum possible distance of a good tuple. If no good tuples exist, return -1.

// Example 1:
// Input: nums = [1,2,1,1,3]
// Output: 6
// Explanation:
// The minimum distance is achieved by the good tuple (0, 2, 3).
// (0, 2, 3) is a good tuple because nums[0] == nums[2] == nums[3] == 1. Its distance is abs(0 - 2) + abs(2 - 3) + abs(3 - 0) = 2 + 1 + 3 = 6.

// Example 2:
// Input: nums = [1,1,2,3,2,1,2]
// Output: 8
// Explanation:
// The minimum distance is achieved by the good tuple (2, 4, 6).
// (2, 4, 6) is a good tuple because nums[2] == nums[4] == nums[6] == 2. Its distance is abs(2 - 4) + abs(4 - 6) + abs(6 - 2) = 2 + 2 + 4 = 8.

// Example 3:
// Input: nums = [1]
// Output: -1
// Explanation:
// There are no good tuples. Therefore, the answer is -1.

// Constraints:
//     1 <= n == nums.length <= 100
//     1 <= nums[i] <= n

import "fmt"

// O(n^3)
func minimumDistance(nums []int) int {
    res, n := 1 << 31, len(nums);
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            for k := j + 1;k < n; k++ {
                if nums[i] == nums[j] && nums[i] == nums[k]{
                    res = min(res,(j - i) + (k - j) + (k - i))
                }
            }
        }
    }
    if res == 1 << 31 { return -1 }
    return res
}

func minimumDistance1(nums []int) int {
    mp := make(map[int][]int)
    inf, res := 1 << 31, 1 << 31
    query := func(arr []int) int {
        if len(arr) < 3 { return inf }
        return 2 * (arr[len(arr) - 1] - arr[len(arr) - 3])
    }
    for i, v := range nums {
        mp[v] = append(mp[v], i)
        if val := query(mp[v]); val < res {
            res = val
        }
    }
    if res == inf { return -1 }
    return res
}

func main() {
    // Example 1:
    // Input: nums = [1,2,1,1,3]
    // Output: 6
    // Explanation:
    // The minimum distance is achieved by the good tuple (0, 2, 3).
    // (0, 2, 3) is a good tuple because nums[0] == nums[2] == nums[3] == 1. Its distance is abs(0 - 2) + abs(2 - 3) + abs(3 - 0) = 2 + 1 + 3 = 6.
    fmt.Println(minimumDistance([]int{1,2,1,1,3})) // 6
    // Example 2:
    // Input: nums = [1,1,2,3,2,1,2]
    // Output: 8
    // Explanation:
    // The minimum distance is achieved by the good tuple (2, 4, 6).
    // (2, 4, 6) is a good tuple because nums[2] == nums[4] == nums[6] == 2. Its distance is abs(2 - 4) + abs(4 - 6) + abs(6 - 2) = 2 + 2 + 4 = 8.
    fmt.Println(minimumDistance([]int{1,1,2,3,2,1,2})) // 8
    // Example 3:
    // Input: nums = [1]
    // Output: -1
    // Explanation:
    // There are no good tuples. Therefore, the answer is -1.
    fmt.Println(minimumDistance([]int{1})) // -1

    fmt.Println(minimumDistance([]int{1,2,3,4,5,6,7,8,9})) // -1
    fmt.Println(minimumDistance([]int{9,8,7,6,5,4,3,2,1})) // -1

    fmt.Println(minimumDistance1([]int{1,2,1,1,3})) // 6
    fmt.Println(minimumDistance1([]int{1,1,2,3,2,1,2})) // 8
    fmt.Println(minimumDistance1([]int{1})) // -1
    fmt.Println(minimumDistance1([]int{1,2,3,4,5,6,7,8,9})) // -1
    fmt.Println(minimumDistance1([]int{9,8,7,6,5,4,3,2,1})) // -1
}