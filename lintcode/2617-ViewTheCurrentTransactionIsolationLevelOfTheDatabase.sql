-- 2617 · View the current transaction isolation level of the database
-- # Description
-- Write SQL statements to see what transaction isolation level you are currently using for your database

-- Example
-- Enter:

-- SHOW VARIABLES like '%isolation%';
-- Return results:

-- Variable_name	Value
-- 'transaction_isolation'	'REPEATABLE-READ'

SHOW VARIABLES like '%isolation%';

-- 数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 
-- # 读未提交 （Read uncommitted）
-- 　
--      读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。
-- 　　  事例： 老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，
--             该钱已经打到程序员的户口，但是事务还没有提交，
--             就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。
--             但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。
--
-- 　　 分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。
--           因此，在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。
--           如无特殊情况，基本是不会使用这种隔离级别的。
--
--  # 读提交（Read Committed）
-- 　　 读提交，顾名思义，就是只能读到已经提交了的内容
-- 　　 事例： 程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），
--            收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。
--            当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。
--            程序员就会很郁闷，明明卡里是有钱的…
-- 　　 分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，
--           可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。
--  　　      这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：
--                  select * from T where ID=2 lock in share mode;
--                  select * from T where ID=2 for update;
-- 　　       不然，普通的查询是不会加锁的。
-- 　　       那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？
-- 　　       这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”
-- 　　       假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞（因为上了X锁，即写锁，所以不能得到S锁，即读锁），
--            这种情况下，并发能力就相当的差。而“快照读”就可以完成高并发的查询，不过，“读提交” 只能避免“脏读”，并不能避免“不可重复读”和“幻读”。
-- 
-- # 可重复读(Repeated Read)
--      可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。
-- 　　 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），
--           收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。
-- 　　 分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。
--           但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。
--     
--     什么时候会出现幻读？
-- 　　  事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），
--            看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。
--            当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。
-- 　　在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作（Update）”了，
--     而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，
--     因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。
-- 
-- # 序列化 Serializable
-- 　　这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。
--     这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。
--
-- 值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。